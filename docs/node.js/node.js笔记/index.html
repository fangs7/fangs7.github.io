<!doctype html>
<html lang="zh" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-node.js/node.js笔记">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.3.1">
<title data-rh="true">node.js笔记 | Fangs-Blog</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://fangs7.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://fangs7.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://fangs7.github.io/docs/node.js/node.js笔记"><meta data-rh="true" name="docusaurus_locale" content="zh"><meta data-rh="true" name="docsearch:language" content="zh"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="node.js笔记 | Fangs-Blog"><meta data-rh="true" name="description" content="一、cmd终端的常见的命令"><meta data-rh="true" property="og:description" content="一、cmd终端的常见的命令"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://fangs7.github.io/docs/node.js/node.js笔记"><link data-rh="true" rel="alternate" href="https://fangs7.github.io/docs/node.js/node.js笔记" hreflang="zh"><link data-rh="true" rel="alternate" href="https://fangs7.github.io/docs/node.js/node.js笔记" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Fangs-Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Fangs-Blog Atom Feed"><link rel="stylesheet" href="/assets/css/styles.3731f85f.css">
<link rel="preload" href="/assets/js/runtime~main.baa843e8.js" as="script">
<link rel="preload" href="/assets/js/main.de774768.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">我的网站</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">笔记</a><a class="navbar__item navbar__link" href="/blog">博客</a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs/node.js/node.js笔记">node.js</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/node.js/node.js笔记">node.js笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/node.js/ServerNotes">ServerNotes</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Rest&amp;AJAX&amp;axios/REST&amp;AJAX&amp;axios">Rest&amp;AJAX&amp;axios</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/git&amp;Webpack/git&amp;webpack">git&amp;Webpack</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Vue/Vue2基础">Vue</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Vue项目笔记/电商项目知识点">Vue项目笔记</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">node.js</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">node.js笔记</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>node.js笔记</h1></header><h4 class="anchor anchorWithStickyNavbar_LWe7" id="一cmd终端的常见的命令">一、cmd终端的常见的命令<a href="#一cmd终端的常见的命令" class="hash-link" aria-label="一、cmd终端的常见的命令的直接链接" title="一、cmd终端的常见的命令的直接链接">​</a></h4><p>1.命令行窗口(小黑屏)、CMD窗口、终端、shell</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">- 开始菜单 --&gt; 运行 --&gt; CMD --&gt; 回车</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 常用的指令：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dir 列出当前目录下的所有文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cd 目录名 进入到指定的目录</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    md 目录名 创建一个文件夹</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    rd 目录名 删除一个文件夹  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 目录</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    . 表示当前目录</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .. 表示上一级目录</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 环境变量（windows系统中变量）    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    path</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        C:\work\jdk\jdk1.7.0_75/bin;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        %CATALINA_HOME%/bin;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        C:\work\soft\tools\AppServ\Apache24\bin;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        C:\work\soft\tools\AppServ\php5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        C:\Users\lilichao\AppData\Local\Programs\Fiddler;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        C:\work\environment\Egret\Egret Wing 3\bin;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        C:\Users\lilichao\AppData\Roaming\npm;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        C:\Program Files\MongoDB\Server\3.2\bin;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        C:\Users\lilichao\Desktop\hello</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 当我们在命令行窗口打开一个文件，或调用一个程序时，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        系统会首先在当前目录下寻找文件程序，如果找到了则直接打开</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        如果没有找到则会依次到环境变量path的路径中寻找，直到找到为止</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        如果没找到则报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 所以我们可以将一些经常需要访问的程序和文件的路径添加到path中，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        这样我们就可以在任意位置来访问这些文件和程序了</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>I/O (Input/Output)</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">- I/O操作指的是对磁盘的读写操作</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Node</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">- Node是对ES标准一个实现，Node也是一个JS引擎</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 通过Node可以使js代码在服务器端执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Node仅仅对ES标准进行了实现，所以在Node中不包含DOM 和 BOM </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Node中可以使用所有的内建对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String Number Boolean Math Date RegExp Function Object Array</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    而BOM和DOM都不能使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        但是可以使用 console 也可以使用定时器（setTimeout() setInterval()）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Node可以在后台来编写服务器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node编写服务器都是单线程的服务器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 进程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - 进程就是一个一个的工作计划（工厂中的车间）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - 线程是计算机最小的运算单位（工厂中的工人）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            线程是干活的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 传统的服务器都是多线程的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 每进来一个请求，就创建一个线程去处理请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Node的服务器单线程的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - Node处理请求时是单线程，但是在后台拥有一个I/O线程池</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="二nodejs">二、node.js<a href="#二nodejs" class="hash-link" aria-label="二、node.js的直接链接" title="二、node.js的直接链接">​</a></h4><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">node.js</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- node是一款对ES标准实现的JS引擎</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 通过node可以使js在服务器中运行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- node就是一款使用js编写的web服务器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- node底层是使用c++的编写的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- node的中js引擎使用的chrome的v8引擎</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- node的特点：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    1.非阻塞、异步的I/O</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    2.事件和回调函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    3.单线程（主线程单线程，后台I/O线程池）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    4.跨平台</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>​	</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="三文件系统file-system">三、文件系统(File System)<a href="#三文件系统file-system" class="hash-link" aria-label="三、文件系统(File System)的直接链接" title="三、文件系统(File System)的直接链接">​</a></h4><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">- Buffer（缓冲区）</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>​		- Buffer和数组的结构的非常类似，Buffer是用来存储二进制数据的
​		- Buffer的方法
​			- Buffer.from(字符串)
​				- 将一个字符串中内容保存到一个buffer中
​			- buf.toString()
​				- 将buffer转换为一个字符串
​			- Buffer.alloc(size)
​				- 创建一个指定大小的buffer对象
​			- Buffer.allocUnsafe(size)
​				- 创建一个指定大小的buffer对象，可以包含敏感数据
​				</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="四fs模块">四、fs模块<a href="#四fs模块" class="hash-link" aria-label="四、fs模块的直接链接" title="四、fs模块的直接链接">​</a></h4><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">- fs模块</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 在Node通过fs模块来对系统中的文件进行操作，fs模块是node中已经继承好了，不需要在使用npm下载，直接引入即可</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 引入fs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        var fs = require(&quot;fs&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - fs模块中的大部分操作都提供了两种方法，同步方法和异步方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        同步方法带sync</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        异步方法没有sync，都需要回调函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 写入文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        1.同步写入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        2.异步写入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        3.简单写入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        4.流式写入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 读取文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        1.同步读取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        2.异步读取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        3.简单读取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        4.流式读取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 方法（被【】括起来的都是可选参数，其他的都是必选参数）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - 打开文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fs.open(path, flags[, mode], callback)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fs.openSync(path, flags[, mode])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - 读写文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fs.write(fd, string[, position[, encoding]], callback)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fs.writeSync(fd, string[, position[, encoding]])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fs.read(fd, buffer, offset, length, position, callback)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fs.readSync(fd, buffer, offset, length, position)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - 关闭文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fs.close(fd,callback)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fs.closeSync(fd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - 简单文件读取和写入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fs.readFile(path[, options], callback) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            path：必选参数，是字符串，表示文件的路径</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            options是可选参数，表示以什么编码格式来读取文件(默认：utf8)（被【】括起来的都是可选参数，其他的都是必选参数）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            callback：必选参数，文件读取完后，通过回调函数拿到读取结果，回调里有两个形参(err，dataStr)表示错误结果和读取结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        成功err为null，失败err就是错误对象，dataStr为undefined</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fs.readFileSync(path[, options])</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>​				fs.writeFile(file, data<!-- -->[, options]<!-- -->, callback)<br>
<!-- -->​					1.只能用来创建文件，不能用来创建路径
​					2.重复调用这个方法，写入同一个文件，新的会覆盖旧的文件
​						file：必选，需要指定一个文件路径的字符串，表示文件的存放路径
​						data：必选，表示要写入的内容
​						options：可选参数，表示以什么编码格式来读取文件(默认：utf8)
​						callback：必选参数，文件写入完成后的回调函数，只有一个形参（err）
​									成功err为null，失败err就是错误对象
​
​				fs.writeFileSync(file, data<!-- -->[, options]<!-- -->)
​
​		****如果出现了路径拼接错误的问题，是因为提供了./或../开头的相对路径，
​		解决办法：1.提供一个完整的路径就可以，直接复制文件的路径，记得将\变成<!-- -->\<!-- -->，因为在js中一个斜线表示转义，两个斜线才表示一个斜线
​					缺点：移植性非常差，不利于维护
​				2.<strong>dirname 表示当前文件夹所处的目录，  例子：</strong>dirname + &#x27;/xxx/xxxxx.js&#x27;</p><p>​
​			- 流式文件读取和写入
​				- 流式读取和写入适用于一些比较大的文件
​					fs.createWriteStream(path<!-- -->[, options]<!-- -->)
​					fs.createReadStream(path<!-- -->[, options]<!-- -->)</p><p>​			</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="五path路径模块">五、path路径模块<a href="#五path路径模块" class="hash-link" aria-label="五、path路径模块的直接链接" title="五、path路径模块的直接链接">​</a></h4><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">如果要在js代码中使用path模块，也是需要导入path，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const path = require(&#x27;path&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">path.join()方法：用来将多个路径片段拼接成一个完整的路径字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            -语法格式：path.join([...paths])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ...paths:是字符串格式，表示路径片段的序列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                返回值：字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">path.basename()方法：可以获取路径中的最后一部分，用来从路径字符串中，将文件名解析出来</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            -语法格式：path.basename(path,ext)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                path:必选参数，字符串，表示一个路径的字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ext:可选参数，字符串，表示文件的扩展名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                返回值：字符串，路径中的最后一部分</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">path.extname():可以获取路径中扩展名部分</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            -语法格式：path.extname(path)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                path：必选参数，字符串，表示一个路径的字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                返回值：字符串，表示返回得到的扩展名字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">path.resolve([…paths]) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - path.resolve(__dirname,path)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                - 用来生成一个绝对路径</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    相对路径：./xxx  ../xxx  xxx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    绝对路径：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        - 在计算机本地</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            c:\xxx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            /User/xxxx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        - 在网络中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            http://www.xxxxx/...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            https://www.xxx/...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    - 如果直接调用resolve，则返回当前的工作目录</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        - 注意，我们通过不同的方式执行代码时，它的工作目录是有可能发生变化的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                - 如果将一个相对路径作为参数，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    则resolve会自动将其转换为绝对路径</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    此时根据工作目录的不同，它所产生的绝对路径也不同</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                - 一般会将一个绝对路径作为第一个参数，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    一个相对路径作为第二个参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    这样它会自动计算出最终的路径</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>​			</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="六http模块">六、http模块<a href="#六http模块" class="hash-link" aria-label="六、http模块的直接链接" title="六、http模块的直接链接">​</a></h4><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">###### 0. http协议 以及 两个面试题</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">HTTP协议</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 网络基础</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 网络的服务器基于请求和响应的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        https:// 协议名  http </span><span class="token function" style="color:#d73a49">ftp</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">..</span><span class="token plain">.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lilichao.com //域名 domain</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            整个网络中存在着无数个服务器，每一个我服务器都有它自己的唯一标识</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                这个标识被称为 ip地址 </span><span class="token number" style="color:#36acaa">192.168</span><span class="token plain">.1.17，但是ip地址不方便记忆</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                域名就相当于是ip地址的别名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /hello/index.html // 网站资源路径</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token number" style="color:#36acaa">1</span><span class="token plain">.当在浏览器中输入地址以后发生了什么？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        https://lilichao.com/hello/index.html</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ① DNS解析，获取网站的ip地址</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ② 浏览器需要和服务器建立连接（tcp/ip）（三次握手）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ③ 向服务器发送请求（http协议）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ④ 服务器处理请求，并返回响应（http协议）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ⑤ 浏览器将响应的页面渲染</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ⑥ 断开和服务器的连接（四次挥手）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token number" style="color:#36acaa">2</span><span class="token plain">. 客户端如何和服务器建立（断开）连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - 通过三次握手和四次挥手</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - 三次握手（建立连接）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                - 三次握手是客户端和服务器建立连接的过程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span><span class="token number" style="color:#36acaa">1</span><span class="token plain">. 客户端向服务器发送连接请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    SYN</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span><span class="token number" style="color:#36acaa">2</span><span class="token plain">. 服务器收到连接请求，向客户端返回消息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    SYN ACK </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span><span class="token number" style="color:#36acaa">3</span><span class="token plain">. 客户端向服务器发送同意连接的信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    ACK</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - 四次挥手（断开连接）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span><span class="token number" style="color:#36acaa">1</span><span class="token plain">. 客户端向服务器发送请求，通过之服务器数据发送完毕，请求断开来接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    FIN</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span><span class="token number" style="color:#36acaa">2</span><span class="token plain">. 服务器向客户端返回数据，知道了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    ACK</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span><span class="token number" style="color:#36acaa">3</span><span class="token plain">. 服务器向客户端返回数据，收完了，可以断开连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    FIN ACK</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span><span class="token number" style="color:#36acaa">4</span><span class="token plain">. 客户端向服务器发数据，可以断开了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    ACK</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        请求和响应实际上就是一段数据，只是这段数据需要遵循一个特殊的格式，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            这个特殊的格式由HTTP协议来规定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">TCP/IP 协议族（了解）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - TCP/IP协议族中包含了一组协议</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        这组协议规定了互联网中所有的通信的细节</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 网络通信的过程由四层组成</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        应用层</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - 软件的层面，浏览器 服务器都属于应用层</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        传输层</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - 负责对数据进行拆分，把大数据拆分为一个一个小包</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        网络层</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - 负责给数据包，添加信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        数据链路层</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - 传输信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - HTTP协议就是应用层的协议，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        用来规定客户端和服务器间通信的报文格式的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 报文（message）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - 浏览器和服务器之间通信是基于请求和响应的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - 浏览器向服务器发送请求（request）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - 服务器向浏览器返回响应（response）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - 浏览器向服务器发送请求相当于浏览器给服务器写信</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                服务器向浏览器返回响应，相当于服务器给浏览器回信</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                这个信在HTTP协议中就被称为报文</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - 而HTTP协议就是对这个报文的格式进行规定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - 服务器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - 一个服务器的主要功能：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token number" style="color:#36acaa">1</span><span class="token plain">.可以接收到浏览器发送的请求报文</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token number" style="color:#36acaa">2</span><span class="token plain">.可以向浏览器返回响应报文</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - 请求报文（request）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - 客户端发送给服务器的报文称为请求报文</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - 请求报文的格式如下：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                请求首行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                请求头</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                空行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                请求体</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                请求首行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    - 请求首行就是请求报文的第一行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        GET /index.html?username</span><span class="token operator" style="color:#393A34">=</span><span class="token plain">sunwukong HTTP/1.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        第一部分 get 表示请求的方式，get表示发送的是get请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            现在常用的方式就是get和post请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            get请求主要用来向服务器请求资源</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            post请求主要用来向服务器发送数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        第二部分 /index.html?username</span><span class="token operator" style="color:#393A34">=</span><span class="token plain">sunwukong</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            表示请求资源的路径，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                ? 后边的内容叫做查询字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                查询字符串是一个名值对结构，一个名字对应一个值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    使用</span><span class="token operator" style="color:#393A34">=</span><span class="token plain">连接，多个名值对之间使用</span><span class="token operator" style="color:#393A34">&amp;</span><span class="token plain">分割</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    </span><span class="token assign-left variable" style="color:#36acaa">username</span><span class="token operator" style="color:#393A34">=</span><span class="token plain">admin</span><span class="token operator" style="color:#393A34">&amp;</span><span class="token assign-left variable" style="color:#36acaa">password</span><span class="token operator" style="color:#393A34">=</span><span class="token number" style="color:#36acaa">123123</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                get请求通过查询字符串将数据发送给服务器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    由于查询字符串会在浏览器地址栏中直接显示</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                        所以，它安全性较差</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                        同时，由于url地址长度有限制，所以get请求无法发送较大的数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                post请求通过请求体来发送数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    - 在chrome中通过 载荷 可以查看</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    post请求通过请求体发送数据，无法在地址栏直接查看</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                        所以安全性较好</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    请求体的大小没有限制，可以发送任意大小的数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                如果你需要向服务器发送数据，能用post尽量使用post</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        第三部分</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            HTTP/1.1 协议的版本</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                请求头</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    - 请求头也是名值对结构，用来告诉服务器我们浏览器的信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    - 每一个请求头都有它的作用：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        Accept 浏览器可以接受的文件类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        Accept-Encoding 浏览器允许的压缩的编码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        User-Agent 用户代理，它是一段用来描述浏览器信息的字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                空行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    - 用来分隔请求头和请求体</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                请求体</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    - post请求通过请求体来发送数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            网页、css、 js、图片这些资源会作为响应报文中的哪一部分发送</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            响应报文：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                响应首行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                响应头</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                空行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                响应体</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                响应首行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    HTTP/1.1 </span><span class="token number" style="color:#36acaa">200</span><span class="token plain"> OK</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        </span><span class="token number" style="color:#36acaa">200</span><span class="token plain"> 响应状态码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ok 对响应状态码的描述</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        - 响应状态码的规则</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            1xx 请求处理中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            2xx 表示成功</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            3xx 表示请求的重定向</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            4xx 表示客户端错误</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            5xx 表示服务器的错误</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                响应头</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    - 响应头也是一个一个的名值对结构，用来告诉浏览器响应的信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    - Content-Type 用来描述响应体的类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    - Content-Length 用来描述响应体大小</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Content-Type: text/html</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token assign-left variable" style="color:#36acaa">charset</span><span class="token operator" style="color:#393A34">=</span><span class="token plain">UTF-8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Content-Length: </span><span class="token number" style="color:#36acaa">2017</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                空行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    - 空行用来分隔响应头和响应体</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                响应体</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    - 响应体就是服务器返回给客户端的内容</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">在网络节点中，负责消费资源的电脑，叫做客户端，负责对外提供网络资源的电脑，就叫做服务器。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">http模块是用来创建 web 服务器的模块，通过http提供的http.createServer()方法，就能把一台普通的电脑，变成一台web服务器，从而对外提供web资源服务。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">如果希望使用http模块创建web服务器，就要先导入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const http = require(&#x27;http&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="1http模块的作用">1.http模块的作用<a href="#1http模块的作用" class="hash-link" aria-label="1.http模块的作用的直接链接" title="1.http模块的作用的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    服务器和普通电脑的区别在于，服务器上安装了 web 服务器软件，例如：IIS、Apache 等。通过安装这些服务器软件，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">就能把一台普通的电脑变成一台 web 服务器。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    在 Node.js 中，我们不需要使用 IIS、Apache 等这些第三方 web 服务器软件。因为我们可以基于 Node.js 提供的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">http 模块，通过几行简单的代码，就能轻松的手写一个服务器软件，从而对外提供 web 服务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="2服务器相关的概念">2.服务器相关的概念<a href="#2服务器相关的概念" class="hash-link" aria-label="2.服务器相关的概念的直接链接" title="2.服务器相关的概念的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">2.1.IP地址</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    IP 地址就是互联网上每台计算机的唯一地址，因此 IP 地址具有唯一性。如果把“个人电脑”比作“一台电话”，那么“IP地</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">址”就相当于“电话号码”，只有在知道对方 IP 地址的前提下，才能与对应的电脑之间进行数据通信。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    IP 地址的格式：通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d 都是 0~255 之间的十进制整数。例如：用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">点分十进表示的 IP地址（192.168.1.1）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--注意：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    1.互联网中每台 Web 服务器，都有自己的 IP 地址，例如：大家可以在 Windows 的终端中运行 ping www.baidu.com 命</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">令，即可查看到百度服务器的 IP 地址。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    2.  在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入 127.0.0.1 这个</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">IP 地址，就能把自己的电脑当做一台服务器进行访问了。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2.2. 域名和域名服务器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    尽管 IP 地址能够唯一地标记网络上的计算机，但IP地址是一长串数字，不直观，而且不便于记忆，于是人们又发明了另一套</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">字符型的地址方案，即所谓的域名（Domain Name）地址。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    IP地址和域名是一一对应的关系，这份对应关系存放在一种叫做域名服务器(DNS，Domain name server)的电脑中。使用者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">只需通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器实现。因此，域名服务器就是提供 IP 地址和域名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">之间的转换服务的服务器。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--注意：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    1.单纯使用 IP 地址，互联网中的电脑也能够正常工作。但是有了域名的加持，能让互联网的世界变得更加方便。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    2.在开发测试期间， 127.0.0.1 对应的域名是 localhost，它们都代表我们自己的这台电脑，在使用效果上没有任何区别</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2.3: 端口号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    计算机中的端口号，就好像是现实生活中的门牌号一样。通过门牌号，外卖小哥可以在整栋大楼众多的房间中，准确把外卖</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">送到你的手中。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    同样的道理，在一台电脑中，可以运行成百上千个 web 服务。每个 web 服务都对应一个唯一的端口号。客户端发送过来的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">网络请求，通过端口号，可以被准确地交给对应的 web 服务进行处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--注意：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    1.每个端口号不能同时被多个 web 服务占用。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    2.在实际应用中，URL 中的 :80 端口可以被省略</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>​			</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="3创建一个简单的服务器">3.创建一个简单的服务器<a href="#3创建一个简单的服务器" class="hash-link" aria-label="3.创建一个简单的服务器的直接链接" title="3.创建一个简单的服务器的直接链接">​</a></h6><ol><li><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1. 创建 web 服务器的基本步骤</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">① 导入 http 模块</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const http = require(&quot;http&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">② 创建 web 服务器实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const server = http.createServer()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">③ 为服务器实例绑定 request 事件，监听客户端的请求(req:请求对象，res:响应对象)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">server.on(&#x27;request&#x27;,(req,res)=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">④ 启动服务器(调用 server.listen(端口号，回调函数) 方法，启动服务器，回调函数在服务器启动的时候就会调用)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">server.listen(8080,()=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2.req：请求对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        只要服务器接收到了客户端的请求，就会调用request回调函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        req 是请求对象，它包含了与客户端相关的数据和属性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        req.url:客户端请求的url地址</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        req.method：是客户端的请求类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3.res：响应对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        在服务器的 request 事件处理函数中，如果想访问与服务器相关的数据或属性，就可以使用 res.end() 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        res.end() 方法的作用：向客户端发送指定的内容，并结束这次请求的处理过程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    例:server.on(&#x27;request&#x27;,(req,res)=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //要发送到客户端的字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            const str = &#x27;abaoicnacni&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res.end(str)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4.解决中文乱码的问题</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        如果发送的字符串中有中文，那么就要设置内容的编译格式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        res.setHeader(&#x27;Content-Type&#x27;,&#x27;text/html; charset=utf-8&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    例:server.on(&#x27;request&#x27;,(req,res)=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //要发送到客户端的字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            const str = &#x27;齐天大圣孙悟空&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //为了防止中文乱码的情况，需要设置响应头</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res.setHeader(&#x27;Content-Type&#x27;,&#x27;text/html; charset=utf-8&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //发送给客户端</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res.end(str)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        })</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li></ol><h6 class="anchor anchorWithStickyNavbar_LWe7" id="4-根据不同的-url-响应不同的-html-内容">4. 根据不同的 url 响应不同的 html 内容<a href="#4-根据不同的-url-响应不同的-html-内容" class="hash-link" aria-label="4. 根据不同的 url 响应不同的 html 内容的直接链接" title="4. 根据不同的 url 响应不同的 html 内容的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1. 核心实现步骤</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">① 获取请求的 url 地址</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">② 设置默认的响应内容为 404 Not found</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">③ 判断用户请求的是否为 / 或 /index.html 首页</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">④ 判断用户请求的是否为 /about.html 关于页面</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">⑤ 设置 Content-Type 响应头，防止中文乱码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">⑥ 使用 res.end() 把内容响应给客户端</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">例子：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">server.on(&#x27;request&#x27;,(req,res)=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const url = req.url</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let content = &#x27;&lt;h1&gt;404&lt;/h1&gt;&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(url === &#x27;/&#x27; || url === &#x27;/index.html&#x27;){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        content = &#x27;&lt;h1&gt;首页&lt;/h1&gt;&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }else if(url === &#x27;/about.html&#x27;){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        content = &#x27;&lt;h1&gt;关于&lt;/h1&gt;&#x27; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    res.setHeader(&#x27;Content-Type&#x27;,&#x27;text/html; charset=utf-8&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    res.end(content)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="七模块化">七、模块化<a href="#七模块化" class="hash-link" aria-label="七、模块化的直接链接" title="七、模块化的直接链接">​</a></h4><h6 class="anchor anchorWithStickyNavbar_LWe7" id="1模块化的概念">1.模块化的概念<a href="#1模块化的概念" class="hash-link" aria-label="1.模块化的概念的直接链接" title="1.模块化的概念的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说，模块是可组合、分解和更换的单元。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 模块化可提高代码的复用性和可维护性，实现按需加载。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 模块化规范是对代码进行模块化拆分和组合时需要遵守的规则，如使用何种语法格式引用模块和向外暴露成员。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="2-nodejs-中的模块化">2. node.js 中的模块化<a href="#2-nodejs-中的模块化" class="hash-link" aria-label="2. node.js 中的模块化的直接链接" title="2. node.js 中的模块化的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">2.1 Node.js 中根据模块来源的不同，将模块分为了 3 大类，分别是：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 内置模块（内置模块是由 Node.js 官方提供的，例如 fs、path、http 等）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 自定义模块（用户创建的每个 .js 文件，都是自定义模块）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 第三方模块（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2.2 在 node.js 中可以使用require()方法，加载需要的内置模块，自定义模块，第三方模块</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - 加载内置模块</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            const fs = require(&#x27;fs&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - 加载自定义模块</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            const custom = require(&#x27;./custom.js&#x27;)   //可以省略后缀名 .js</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - 加载第三方模块</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            const moment = require(&#x27;moment&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">注意：使用require()方法加载模块时，会执行被加载模块中的代码</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="3-nodejs中的模块作用域">3. node.js中的模块作用域<a href="#3-nodejs中的模块作用域" class="hash-link" aria-label="3. node.js中的模块作用域的直接链接" title="3. node.js中的模块作用域的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">好处：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 防止全局变量污染</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="4模块作用域的成员">4.模块作用域的成员<a href="#4模块作用域的成员" class="hash-link" aria-label="4.模块作用域的成员的直接链接" title="4.模块作用域的成员的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">4.1、module对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">在每个 .js 自定义模块中都有一个 module 对象，它里面存储了和当前模块有关的信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4.2、module.exports对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    在自定义模块中，可以使用 module.exports 对象，将模块内的成员共享出去，供外界使用。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    外界用 require() 方法导入自定义模块时，得到的就是 module.exports 所指向的对象。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">注意：使用require()方法导入自定义模块的时候，导入的结果永远以 module.exports 指向的对象为准</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4.3、exports 对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    由于 module.exports 单词写起来比较复杂，为了简化向外共享成员的代码，Node 提供了 exports 对象。默认情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">下，exports 和 module.exports 指向同一个对象。最终共享的结果，还是以 module.exports 指向的对象为准</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">注意：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - require()方法导入的模块，永远以 module.exports 指向的对象为准</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 为了防止混乱，建议大家不要在同一个模块中同时使用 exports 和 module.exports</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="5nodejs-的模块化规范">5.node.js 的模块化规范<a href="#5nodejs-的模块化规范" class="hash-link" aria-label="5.node.js 的模块化规范的直接链接" title="5.node.js 的模块化规范的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Node.js 遵循了 CommonJS 模块化规范，CommonJS 规定了模块的特性和各模块之间如何相互依赖。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CommonJS 规定：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - 每个模块内部，module 变量代表当前模块。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - module 变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - 加载某个模块，其实是加载该模块的 module.exports 属性。require() 方法用于加载模块。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">默认情况下，node中的模块化标准是CommonJS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        要想使用ES的模块化，可以采用以下两种方案</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            1. 使用mjs作为扩展名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            2. 修改package.json将模块化规范设置为ES模块</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                当我们设置 &quot;type&quot;: &quot;module&quot; 当前项目下所有的js文件都默认为es module</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="6模块的加载机制">6.模块的加载机制<a href="#6模块的加载机制" class="hash-link" aria-label="6.模块的加载机制的直接链接" title="6.模块的加载机制的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">模块第一次加载后会被缓存，即多次调用 require() 不会导致模块的代码被执行多次，提高模块加载效率。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1.内置模块加载</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    内置模块加载优先级最高。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2.自定义模块加载</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    加载自定义模块时，路径要以 ./ 或 ../ 开头，否则会作为内置模块或第三方模块加载。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    导入自定义模块时，若省略文件扩展名，则 Node.js 会按顺序尝试加载文件：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        1. 按确切的文件名加载</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        2. 补全 .js 扩展名加载</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        3. 补全 .json 扩展名加载</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        4. 补全 .node 扩展名加载</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        5. 报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3.第三方模块加载</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    若导入第三方模块， Node.js 会从当前模块的父目录开始，尝试从 /node_modules 文件夹中加载第三方模块。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    例如，假设在 C:\Users\bruce\project\foo.js 文件里调用了 require(&#x27;tools&#x27;)，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    则 Node.js 会按以下顺序查找：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                1. C:\Users\bruce\project\node_modules\tools</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                2. C:\Users\bruce\node_modules\tools</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                3. C:\Users\node_modules\tools</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                4. C:\node_modules\tools</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4.目录（文件夹）作为模块加载</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 当把目录作为模块标识符进行加载的时候，有三种加载方式：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    1.在被加载的目录下查找 package.json 的文件，并寻找 main 属性，作为 require() 加载的入口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    2. 如果没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    3. 如果以上两步都失败了，则 Node.js 会在终端打印错误消息，报告模块的缺失：Error: Cannot find module &#x27;xxx&#x27;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="八npm与包">八、npm与包<a href="#八npm与包" class="hash-link" aria-label="八、npm与包的直接链接" title="八、npm与包的直接链接">​</a></h4><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm的命令:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - npm -v 查看npm的版本</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - npm version 查看所有模块的版本</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - npm search 包名 搜索包</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - npm install / i 包名 安装包</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - npm remove / r 包名 删除包</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - npm install 包名 --save 安装包并添加到依赖中 *****</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - npm install 下载当前项目所依赖的包</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - npm install 包名 -g 全局安装包（全局安装的包一般都是一些工具）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 包（package） Node.js 中的第三方模块又叫做包，第三方模块和包指的是同一个概念，叫法不同</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 将多个模块组合为一个完整的功能，就是一个包</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 包结构</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bin</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - 二进制的可执行文件，一般都是一些工具包中才有</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lib</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - js文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        doc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - 文档</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - 测试代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        package.json</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - 包的描述文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - package.json  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - 它是一个json格式的文件，在它里面保存了包各种相关的信息，用来记录与项目有关的一些配置信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            name 包名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            version 版本</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            dependencies 依赖</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                -package.json 文件中，有一个 dependencies 节点，专门用来记录您使用 npm install 命令安装了哪些包。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                -如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到 dependencies 节点中。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            devDependencies 节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                -如果某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到 devDependencies 节点中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                - npm i 包名 -D   安装指定的包，将包记录到 devDependencies 节点中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            main 包的入口文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            bin 可执行文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            scripts:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     - 可以自定义一些命令</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     - 定义以后可以直接通过npm来执行这些命令</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     - start 和 test 可以直接通过 npm start npm test执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     - 其他命令需要通过npm run xxx 执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -快速创建一个package.json 文件，在终端中运行 npm init -y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            注意：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                1. 上述命令只能在英文的目录下成功运行！所以，项目文件夹的名称一定要使用英文命名，不要使用中文，不能出现空格。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                2. 运行 npm install 命令安装包的时候，npm 包管理工具会自动把包的名称和版本号，记录到 package.json 中。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">包的版本号是以“点分十进制”形式进行定义的，总共有三位数字，例如 2.24.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">其中每一位数字所代表的的含义如下：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">第1位数字：大版本</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">第2位数字：功能版本</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">第3位数字：Bug修复版本</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">版本号提升的规则：只要前面的版本号增长了，则后面的版本号归零</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- npm（Node Package Manager node的包管理器）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 通过npm可以对node中的包进行上传、下载、搜索等操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - npm会在安装完node以后，自动安装</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - npm的常用指令</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        npm -v 查看npm的版本</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        npm version 查看所有模块的版本</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        npm init 初始化项目（创建package.json）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        npm i/install 包名 安装指定的包</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        npm i/install 包名 --save 安装指定的包并添加依赖</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        npm i/install 包名 -g 全局安装（一般都是一些工具）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        npm i/install 安装当前项目所依赖的包</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        npm s/search 包名 搜索包 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        npm r/remove 包名 删除一个包</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        npm uninstall 包名 卸载一个包  该命令执行成功后，会把卸载的包，自动从 package.json 的 dependencies 中移除掉。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">node_modules 文件夹用来存放所有已安装到项目中的包。require() 导入第三方包时，就是从这个目录中查找并加载包。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">package-lock.json 配置文件用来记录 node_modules 目录下的每一个包的下载信息，例如包的名字、版本号、下载地址等。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">默认情况下，使用 npm i 安装包的时候，会自动安装最新版本的包。如果需要安装指定版本的包，可以在包名之后，通过 @ 符号指定具体的版本</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="1切换npm镜像源">1.切换npm镜像源<a href="#1切换npm镜像源" class="hash-link" aria-label="1.切换npm镜像源的直接链接" title="1.切换npm镜像源的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cmd打开命令行窗口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm config get registry     查看当前的下包镜像源</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm config set registry=https://registry.npm.taobao.org/    将下包镜像源切换到淘宝镜像源</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">为了更方便的切换下包的镜像源，我们可以安装 nrm 这个小工具，利用 nrm 提供的终端命令，可以快速查看和切换下包的镜像源。 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    npm i nrm -g    将nrm下载为全局可用的工具</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    nrm ls  查看所有可用的镜像源</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    nrm use taobao  将下包的镜像切换为淘宝的镜像</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="2-包的分类">2. 包的分类<a href="#2-包的分类" class="hash-link" aria-label="2. 包的分类的直接链接" title="2. 包的分类的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1.项目包</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -那些被安装到项目的 node_modules 目录中的包，都是项目包。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    项目包又分为两类，分别是：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    - 开发依赖包（被记录到 devDependencies 节点中的包，只在开发期间会用到）   npm i 包名 -D</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    - 核心依赖包（被记录到 dependencies 节点中的包，在开发期间和项目上线之后都会用到）   npm i 包名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2.全局包</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 在执行 npm install 命令时，如果提供了 -g 参数，则会把包安装为全局包。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      全局包会被安装到 C:\Users\用户目录\AppData\Roaming\npm\node_modules 目录下</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">注意：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ① 只有工具性质的包，才有全局安装的必要性。因为它们提供了好用的终端命令。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ② 判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">i5ting_toc 是一个可以把 md 文档转为 html 页面的小工具，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">使用步骤如下：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    npm i i5ting_toc -g</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    i5ting_toc -f 要转换的md文件路径 -o</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="3规范的包结构">3.规范的包结构<a href="#3规范的包结构" class="hash-link" aria-label="3.规范的包结构的直接链接" title="3.规范的包结构的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">一个规范的包，它的组成结构，必须符合以下 3 点要求：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">① 包必须以单独的目录而存在</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">② 包的顶级目录下要必须包含 package.json 这个包管理配置文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">③ package.json 中必须包含 name，version，main 这三个属性，分别代表包的名字、版本号、包的入口</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="4发布包">4.发布包<a href="#4发布包" class="hash-link" aria-label="4.发布包的直接链接" title="4.发布包的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1.在npm官网注册npm账号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2.在终端输入 npm login 登录npm账号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -在运行 npm login 命令之前，必须先把下包的服务器地址切换为 npm 的官方服务器。否则会导致发布包失败！</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3.将终端切换到包的根目录之后，运行 npm publish 命令，即可将包发布到 npm 上（注意：包名不能雷同）。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4.删除已发布的包</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -运行 npm unpublish 包名 --force 命令，即可从 npm 删除已发布的包。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    注意：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ① npm unpublish 命令只能删除 72 小时以内发布的包</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ② npm unpublish 删除的包，在 24 小时内不允许重复发布</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ③ 发布包的时候要慎重，尽量不要往 npm 上发布没有意义的包！</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>​			</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="九express">九、express<a href="#九express" class="hash-link" aria-label="九、express的直接链接" title="九、express的直接链接">​</a></h4><h6 class="anchor anchorWithStickyNavbar_LWe7" id="1express基础">1.express基础<a href="#1express基础" class="hash-link" aria-label="1.express基础的直接链接" title="1.express基础的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1.express简介：express就是基于http模块封装出来的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    官方给出的概念：Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    通俗的理解：Express 的作用和 Node.js 内置的 http 模块类似，是专门用来创建 Web 服务器的。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Express 的本质：就是一个 npm 上的第三方包，提供了快速创建 Web 服务器的便捷方法。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="2用express创建一个简单的服务器">2.用express创建一个简单的服务器<a href="#2用express创建一个简单的服务器" class="hash-link" aria-label="2.用express创建一个简单的服务器的直接链接" title="2.用express创建一个简单的服务器的直接链接">​</a></h6><div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token number" style="color:#36acaa">1.</span><span class="token plain">安装</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    终端输入 npm i express@</span><span class="token number" style="color:#36acaa">4.17</span><span class="token number" style="color:#36acaa">.1</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token number" style="color:#36acaa">2.</span><span class="token plain">创建一个简单的服务器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token number" style="color:#36acaa">2.1</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">导入express</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> express </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">require</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27;express&#x27;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token number" style="color:#36acaa">2.2</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">创建web服务器</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> app </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">express</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token number" style="color:#36acaa">2.4</span><span class="token plain"> 监听get</span><span class="token operator" style="color:#393A34">||</span><span class="token plain">post请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token number" style="color:#36acaa">2.3</span><span class="token plain"> 调用 app</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">listen</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">端口号，启动成功的回调</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain">，启动服务器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        app</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">listen</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">8080</span><span class="token punctuation" style="color:#393A34">,</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token arrow operator" style="color:#393A34">=&gt;</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token comment" style="color:#999988;font-style:italic">//服务器启动成功后执行</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="3getpost-请求知识点">3.get||post 请求知识点<a href="#3getpost-请求知识点" class="hash-link" aria-label="3.get||post 请求知识点的直接链接" title="3.get||post 请求知识点的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1. 监听 get 请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">通过 app.get() 方法，可以监听客户端的 GET 请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    app.get(&#x27;请求地址&#x27;,(req,res)=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        参数1：客户端请求的地址</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        参数2：客户端请求时的回调函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            req：请求对象（包含了请求相关的属性和方法）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                req.get(&quot;Authorization&quot;)    //获取`Authorization`请求头的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res：响应对象（包含了响应相关的属性和方法）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res 表示的服务器发送给客户端的响应信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    - 可以通过res来向客户端返回数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    - sendStatus() 向客户端发送响应状态吗</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    - status() 用来设置响应状态吗，但是并不发送</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    - send() 设置并发送响应体</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    - res.sendStatus(404)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    - res.status(200)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2. 监听 post 请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">通过 app.post() 方法，可以监听客户端的 POST 请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    app.post(&#x27;请求地址&#x27;,(req,res)=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        参数1：客户端请求的地址</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        参数2：客户端请求时的回调函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            req：请求对象（包含了请求相关的属性和方法）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res：响应对象（包含了响应相关的属性和方法）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3. 可以使用 res.send() 方法，将处理好的内容，发送给客户端</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4.  获取 URL 中携带的查询参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 通过 req.query 对象，可以访问到客户端通过查询字符串的形式，发送到服务器的参数：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        req.query 默认是一个空对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        客户端使用 在url后面 ?name=zs&amp;age=18 这种形式，将参数发送给服务器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        而服务器可以通过 req.query.name  req.query.age 获取到</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5. 获取 URL 中的动态参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">通过 req.params 对象，可以访问到 URL 中，通过 : 匹配到的动态参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">app.get(&#x27;/user/:id/:name&#x27;,(req,res)=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    req.params 默认是空对象，里面存放着通过 : 动态匹配到的参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">注意：:是必不可少的，后面的属性名可以修改，可以带多个params参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6.可以使用 req.body 获取到客户端发送的请求体数据</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="4托管静态资源">4.托管静态资源<a href="#4托管静态资源" class="hash-link" aria-label="4.托管静态资源的直接链接" title="4.托管静态资源的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1. express.static()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    由于服务器的数据是不对外暴露的，但是如果想要外界看到某个静态资源，express 提供了一个非常好用的函数，叫做 express.static()，通过它，我们可以非常方便地创建一个静态资源服务器。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">例如，通过 app.use(express.static(&#x27;public&#x27;)) 就可以将 public 目录下的图片、CSS 文件、JavaScript 文件对外开放访问了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">注意：Express 在指定的静态目录中查找文件，并对外提供资源的访问路径。因此，存放静态文件的目录名不会出现在 URL 中。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">例：http://localhost:3000/images/bg.jpg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2. 托管多个静态资源目录</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">如果要托管多个静态资源目录，请多次调用 express.static() 函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">访问静态资源文件时，express.static() 函数会根据目录的添加顺序查找所需的文件(谁先添加的就先在谁那里查找)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3. 挂载路径前缀</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">如果希望在托管的静态资源访问路径之前，挂载路径前缀，则可以使用 app.use(&#x27;public&#x27;,express.static(&#x27;public&#x27;))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">例：http://localhost:3000/public/images/kitten.jpg</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="5nodemon">5.nodemon<a href="#5nodemon" class="hash-link" aria-label="5.nodemon的直接链接" title="5.nodemon的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">在编写调试 Node.js 项目的时候，如果修改了项目的代码，则需要频繁的手动 close 掉，然后再重新启动，非常繁琐。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">现在，我们可以使用 nodemon（https://www.npmjs.com/package/nodemon） 这个工具，它能够监听项目文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">的变动，当代码被修改后，nodemon 会自动帮我们重启项目，极大方便了开发和调试</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1.安装nodemon </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">终端  npm i nodemon -g</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2.使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">当基于 Node.js 编写了一个网站应用的时候，传统的方式，是运行 node app.js 命令，来启动项目。这样做的坏处是：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">代码被修改之后，需要手动重启项目。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">现在，我们可以将 node 命令替换为 nodemon 命令，使用 nodemon app.js 来启动项目。这样做的好处是：代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">被修改之后，会被 nodemon 监听到，从而实现自动重启项目的效果</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="十express路由">十、express路由<a href="#十express路由" class="hash-link" aria-label="十、express路由的直接链接" title="十、express路由的直接链接">​</a></h4><h6 class="anchor anchorWithStickyNavbar_LWe7" id="1路由的概念">1.路由的概念<a href="#1路由的概念" class="hash-link" aria-label="1.路由的概念的直接链接" title="1.路由的概念的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">在 Express 中，路由指的是客户端的请求与服务器处理函数之间的映射关系。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Express 中的路由分 3 部分组成，分别是请求的类型、请求的 URL 地址、处理函数，即 app.method(path,callback)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="2路由的匹配过程">2.路由的匹配过程<a href="#2路由的匹配过程" class="hash-link" aria-label="2.路由的匹配过程的直接链接" title="2.路由的匹配过程的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">每当一个请求到达服务器之后，需要先经过路由的匹配，只有匹配成功之后，才会调用对应的处理函数。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的 URL 同时匹配成功，则 Express 会将这次请求，转</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">交给对应的 function 函数进行处理。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">路由匹配的注意点：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">① 按照定义的先后顺序进行匹配</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">② 请求类型和请求的URL同时匹配成功，才会调用对应的处理函数</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="3模块化路由">3.模块化路由<a href="#3模块化路由" class="hash-link" aria-label="3.模块化路由的直接链接" title="3.模块化路由的直接链接">​</a></h6><div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">为了方便对路由进行模块化的管理，Express 不建议将路由直接挂载到 app 上，而是推荐将路由抽离为单独的模块。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">将路由抽离为单独模块的步骤如下：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">① 创建路由模块对应的 </span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">js</span><span class="token plain"> 文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">② 调用 express</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access maybe-class-name" style="color:#d73a49">Router</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> 函数创建路由对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">③ 向路由对象上挂载具体的路由</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">④ 使用 module</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">exports</span><span class="token plain"> 向外共享路由对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">⑤ 使用 app</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">use</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> 函数注册路由模块</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token number" style="color:#36acaa">1.</span><span class="token plain">首先创建一个路由模块的js文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">//1.导入express模块</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> express </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">require</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27;express&#x27;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">//2.创建路由对象</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> router </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> express</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access maybe-class-name" style="color:#d73a49">Router</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">//3.监听get||post请求</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        router</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">get</span><span class="token operator" style="color:#393A34">||</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">post</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27;/user/list&#x27;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token punctuation" style="color:#393A34">(</span><span class="token parameter">req</span><span class="token parameter punctuation" style="color:#393A34">,</span><span class="token parameter">res</span><span class="token punctuation" style="color:#393A34">)</span><span class="token arrow operator" style="color:#393A34">=&gt;</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">send</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27;hello&#x27;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">//4.向外导出路由对象</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        module</span><span class="token punctuation" style="color:#393A34">.</span><span class="token keyword module" style="color:#00009f">export</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> router</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token number" style="color:#36acaa">2.</span><span class="token plain">在服务器中注册路由模块</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> express </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">require</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27;express&#x27;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> app </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">express</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">//1.导入路由模块</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> router </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">require</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27;./router.js&#x27;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">//2.注册路由模块  /api 为统一的访问前缀</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    app</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">use</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27;/api&#x27;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">router</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    app</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">listen</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27;80&#x27;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token arrow operator" style="color:#393A34">=&gt;</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token function" style="color:#d73a49">log</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27;服务器启动了。&#x27;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="十一express中间件">十一、express中间件<a href="#十一express中间件" class="hash-link" aria-label="十一、express中间件的直接链接" title="十一、express中间件的直接链接">​</a></h4><h6 class="anchor anchorWithStickyNavbar_LWe7" id="1中间件的概念">1.中间件的概念<a href="#1中间件的概念" class="hash-link" aria-label="1.中间件的概念的直接链接" title="1.中间件的概念的直接链接">​</a></h6><div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">中间件（Middleware ），特指业务流程的中间处理环节。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">中间件是指流程的中间处理环节</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">当一个请求到达 Express 的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">中间件是一个函数，包含 req, res, next 三个参数，next</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> 参数把流转关系交给下一个中间件或路由</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">中间件注意事项；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token number" style="color:#36acaa">1</span><span class="token plain">. 在注册路由之前注册中间件（错误级别中间件除外）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token number" style="color:#36acaa">2</span><span class="token plain">. 中间件可连续调用多个</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token number" style="color:#36acaa">3</span><span class="token plain">. 别忘记调用 next</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> 函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token number" style="color:#36acaa">4</span><span class="token plain">. next</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> 函数后别写代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token number" style="color:#36acaa">5</span><span class="token plain">. 多个中间件共享 req、 res对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="2全局中间件">2.全局中间件<a href="#2全局中间件" class="hash-link" aria-label="2.全局中间件的直接链接" title="2.全局中间件的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">客户端发起的任何请求，到达服务器之后，都会触发的中间件，叫做全局生效的中间件。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">通过调用 app.use(中间件函数)，即可定义一个全局生效的中间件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    app.use((req,res,next)=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        next()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">作用：多个中间件之间，共享同一份 req 和 res。基于这样的特性，我们可以在前面的中间件中，统一为 req 或 res 对象添加自定义的属性    或方法，供后面的中间件或路由进行使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">也可以使用 app.use() 连续定义多个全局中间件。客户端请求到达服务器之后，会按照中间件定义的先后顺序依次进行调用</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="3局部生效的中间件">3.局部生效的中间件<a href="#3局部生效的中间件" class="hash-link" aria-label="3.局部生效的中间件的直接链接" title="3.局部生效的中间件的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">不使用 app.use() 定义的中间件，叫做局部生效的中间件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">局部生效的中间件 就是只在某一个或者某几个路由中生效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//1. 定义一个中间件函数mw1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const mw1 = function(req,res,next){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        log(&#x27;这是局部生效中间件&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        next()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//2. mw1 这个中间件只在 这个路由中 生效，不会影响其他路由</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    app.get(&#x27;/user&#x27;,mw1,()=&gt;{})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">定义多个局部生效的中间件    **两种方法是等价的**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">app.get(&#x27;/user&#x27;,mw1,mw2,()=&gt;{})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">app/get(&#x27;/user&#x27;,[mw1,mw2],()=&gt;{}))</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>中间件的5个使用注意事项</strong></p><p>① 一定要在路由之前注册中间件</p><p>② 客户端发送过来的请求，可以连续调用多个中间件进行处理</p><p>③ 执行完中间件的业务代码之后，不要忘记调用 next() 函数</p><p>④ 为了防止代码逻辑混乱，调用 next() 函数后不要再写额外的代码</p><p>⑤ 连续调用多个中间件时，多个中间件之间，共享 req 和 res 对象</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="4中间件的分类">4.中间件的分类<a href="#4中间件的分类" class="hash-link" aria-label="4.中间件的分类的直接链接" title="4.中间件的分类的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1. 应用级别的中间件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">通过 app.use() 或 app.get() 或 app.post() ，绑定到 app 实例上的中间件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2. 路由级别的中间件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">绑定到 express.Router() 实例上的中间件，叫做路由级别的中间件。用法和应用级别中间件没有区别。应用级别中间件是绑定到 app 实例上，路由级别中间件绑定到 router 实例上。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3. 错误级别的中间件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">错误级别中间件的处理函数中，必须有 4 个形参，形参顺序从前到后分别是 (err, req, res, next) 。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">错误级别的中间件必须注册在所有路由之后</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const express = require(&#x27;express&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const app = express()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">app.get(&#x27;/user&#x27;,(req,res)=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //抛出错误</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throw new Error(&#x27;服务器发送错误&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    res.send(&#x27;ok&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//定义错误级别的中间件，捕获整个项目的异常错误，从而防止程序的崩溃</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">app.use((err,req,res,next)=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    res.send(&#x27;Error:&#x27;+ err.message)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">app.listen(...)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4. Express 内置中间件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大的提高了 Express 项目的开发效率和体验：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">express.static 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">express.json 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">express.urlencoded 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">app.use(express.json())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">app.use(express.urlencoded({ extended: false }))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//这两个用来解析客户端发送的请求的请求体上所携带的json和url-encoded格式的数据，没有配置的话，默认是undefined</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5.第三方中间件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">① 运行 npm install body-parser 安装中间件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">② 使用 require 导入中间件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">③ 调用 app.use() 注册并使用中间件</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="十二cors--jsonp仅支持get请求-解决跨域问题">十二、CORS || JSONP(仅支持GET请求) 解决跨域问题<a href="#十二cors--jsonp仅支持get请求-解决跨域问题" class="hash-link" aria-label="十二、CORS || JSONP(仅支持GET请求) 解决跨域问题的直接链接" title="十二、CORS || JSONP(仅支持GET请求) 解决跨域问题的直接链接">​</a></h4><h6 class="anchor anchorWithStickyNavbar_LWe7" id="1使用cors解决跨域问题">1.使用CORS解决跨域问题<a href="#1使用cors解决跨域问题" class="hash-link" aria-label="1.使用CORS解决跨域问题的直接链接" title="1.使用CORS解决跨域问题的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1. 安装中间件：npm install cors</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2. 导入中间件：const cors = require(&#x27;cors&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3. 配置中间件：app.use(cors())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="2-cors的基本概念">2. CORS的基本概念<a href="#2-cors的基本概念" class="hash-link" aria-label="2. CORS的基本概念的直接链接" title="2. CORS的基本概念的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">- 概念</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CORS（Cross-Origin Resource Sharing，跨域资源共享）解决跨域，是通过 HTTP 响应头决定浏览器是否阻止前端 JS 代码跨域获取资源</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了 CORS 相关的 HTTP 响应头，就可解除浏览器端的跨域访问限制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-注意：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CORS 主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了 CORS 的接口。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CORS 在浏览器中有兼容性。只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="3-cors常用响应头">3. CORS常用响应头<a href="#3-cors常用响应头" class="hash-link" aria-label="3. CORS常用响应头的直接链接" title="3. CORS常用响应头的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1. Access-Control-Allow-Origin  制定了允许访问资源的外域 URL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;http://bruceblog.io&#x27;)     仅支持http://bruceblog.io访问</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;)       所有url都可以访问</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">2.Access-Control-Allow-Headers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头：Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type （值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求会失败！</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">res.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;Content-Type, X-Custom-Header&#x27;)  //多个请求头之间用，分开</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">3. Access-Control-Allow-Methods</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods 来指明实际请求所允许使用的 HTTP 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;POST, GET, DELETE, HEAD&#x27;)    //只允许这四个方法请求服务器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">res.setHEader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;*&#x27;)      //允许所有的http请求方法</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="4cors-请求的分类">4.CORS 请求的分类<a href="#4cors-请求的分类" class="hash-link" aria-label="4.CORS 请求的分类的直接链接" title="4.CORS 请求的分类的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">客户端在请求 CORS 接口时，根据请求方式和请求头的不同，可以将 CORS 的请求分为两大类，分别是：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1. 简单请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ① 请求方式：GET、POST、HEAD 三者之一</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ② HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值application/x-www-form-urlencoded、       multipart/form-data、text/plain）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2. 预检请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ① 请求方式为 GET、POST、HEAD 之外的请求 Method 类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ② 请求头中包含自定义头部字段</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ③ 向服务器发送了 application/json 格式的数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">简单请求和预检请求的区别</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 简单请求的特点：客户端与服务器之间只会发生一次请求。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 预检请求的特点：客户端与服务器之间会发生两次请求，OPTION 预检请求成功之后，才会发起真正的请求。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="5-jsonp">5. JSONP<a href="#5-jsonp" class="hash-link" aria-label="5. JSONP的直接链接" title="5. JSONP的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">概念：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    浏览器端通过 &lt;script&gt; 标签的 src 属性，请求服务器上的数据，同时，服务器返回一个函数的调用。这种请求数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">的方式叫做 JSONP。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">特点：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ① JSONP 不属于真正的 Ajax 请求，因为它没有使用 XMLHttpRequest 这个对象。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ② JSONP 仅支持 GET 请求，不支持 POST、PUT、DELETE 等请求。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">注意：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    如果项目中已经配置了 CORS 跨域资源共享，为了防止冲突，必须在配置 CORS 中间件之前声明 JSONP 的接口。否则</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">JSONP 接口会被处理成开启了 CORS 的接口。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">实现 JSONP 接口的步骤：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    1. 获取客户端发送过来的回调函数的名字</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    2. 得到要通过 JSONP 形式发送给客户端的数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    3. 根据前两步得到的数据，拼接出一个函数调用的字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    4. 把上一步拼接得到的字符串，响应给客户端的 &lt;script&gt; 标签进行解析执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">具体代码：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    app.get(&#x27;/api/jsonp&#x27;,(req,res)=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        const funcName = req.query.callback</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        const data = {name:&#x27;zs&#x27;,age:18}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        const scritStr = `${funcName}(${JSON.stringify(data)})`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        req.send(scriptStr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">在网页中使用jQuery发起ajax请求：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    $(&#x27;#btnJSONP&#x27;).on(&#x27;click&#x27;,()=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        $.ajax({</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            method:&#x27;get&#x27;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            url:&#x27;http://127.0.0.1/api/jsonp&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            dataType:&#x27;jsonp&#x27;    //表示要发送 jsonp 请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            success: function(res){}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="十三mysql数据库">十三、MySQL数据库<a href="#十三mysql数据库" class="hash-link" aria-label="十三、MySQL数据库的直接链接" title="十三、MySQL数据库的直接链接">​</a></h4><h6 class="anchor anchorWithStickyNavbar_LWe7" id="1-数据库基本使用">1. 数据库基本使用<a href="#1-数据库基本使用" class="hash-link" aria-label="1. 数据库基本使用的直接链接" title="1. 数据库基本使用的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">DataType 数据类型：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">① int 整数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">② varchar(len) 字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">③ tinyint(1) 布尔值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">字段的特殊标识：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">① PK（Primary Key）主键、唯一标识</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">② NN（Not Null）值不允许为空</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">③ UQ（Unique）值唯一</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">④ AI（Auto Increment）值自动增长</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Default：默认值</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="2-增删改查的sql语句">2. 增删改查的SQL语句<a href="#2-增删改查的sql语句" class="hash-link" aria-label="2. 增删改查的SQL语句的直接链接" title="2. 增删改查的SQL语句的直接链接">​</a></h6><p>​		---  <strong>注意</strong>：SQL 语句中的关键字对<strong>大小写不敏感</strong>。SELECT 等效于 select，FROM 等效于 from</p><p><strong>千万不要忘记where！！！！</strong></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1. SELECT 语句用于从表中查询数据。执行的结果被存储在一个结果表中（称为结果集）。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">语法：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - select * from 表名      //从from指定的表中，查询所有的列数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - select 列名 from 表名     //从from指定的表中，查询指定的列名的数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">示例：select * from users</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     select id,username from users</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">2. INSERT INTO 语句用于向数据表中插入新的数据行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">语法：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - insert into 表名(要添加的列名...) values (对应的值...)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">示例：向 users 表中，插入一条 username 为 tony stark，password 为 098123 的用户数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - insert into users(username,password) values(&#x27;tony stark&#x27;,&#x27;098123&#x27;)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">3. Update 语句用于修改表中的数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">语法: - update 表名 set 列名=新值 where 更新的条件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">示例：1. 把 users 表中 id 为 7 的用户密码，更新为 888888</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - update users set password=888888 where id=7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    2. 把 users 表中 id 为 2 的用户密码和用户状态，分别更新为 admin123 和 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - update users set password=&#x27;admin123&#x27;,status=1 where id=2</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">4. DELETE 语句用于删除表中的行。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">语法： - delete from 表名 where 列名称=值        //从指定的表中，根据where，删除对应的数据行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">示例：从 users 表中，删除 id 为 4 的用户</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - delete from users where id=4</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="3-where子句andor">3. where子句|and|or<a href="#3-where子句andor" class="hash-link" aria-label="3. where子句|and|or的直接链接" title="3. where子句|and|or的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">WHERE 子句用于限定选择的标准。在 SELECT、UPDATE、DELETE 语句中，皆可使用 WHERE 子句来限定选择的标准</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">可以使用 =  !=/&lt;&gt;  &lt;  &gt;  &gt;=  &lt;=   between(在某个范围内)   like(模糊搜索)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- select * from users where id&gt;2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">AND 表示必须同时满足多个条件，相当于 JavaScript 中的 &amp;&amp; 运算符，例如 if (a !== 10 &amp;&amp; a !== 20)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">OR 表示只要满足任意一个条件即可，相当于 JavaScript 中的 || 运算符，例如 if(a !== 10 || a !== 20)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="4-order-by-子句">4. order by 子句<a href="#4-order-by-子句" class="hash-link" aria-label="4. order by 子句的直接链接" title="4. order by 子句的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ORDER BY 语句用于根据指定的列对结果集进行排序。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ORDER BY 语句默认按照升序对记录进行排序。   asc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">如果您希望按照降序对记录进行排序，可以使用 DESC 关键字</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1. 对 users 表中的数据，按照 status 字段进行升序排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - select * from users order by status asc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2. 对 users 表中的数据，按照 id 字段进行降序排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - select * from users order by id desc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3. 对 users 表中的数据，先按照 status 字段进行降序排序，再按照 username 的字母顺序，进行升序排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - select * from users order by status desc,username asc</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="5-count--as-关键字">5. count(*) || as 关键字<a href="#5-count--as-关键字" class="hash-link" aria-label="5. count(*) || as 关键字的直接链接" title="5. count(*) || as 关键字的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1. COUNT(*) 函数用于返回查询结果的总数据条数，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - select count(*) from 表名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">示例：查询 users 表中 status 为 0 的总数据条数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - select count(*) from users where status=0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2.  使用 AS 为列设置别名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">如果希望给查询出来的列名称设置别名，可以使用 AS 关键字</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">示例：- select count(*) as total from users where status=0     //total就是这个查询结果的名称</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="6-在项目中连接mysql">6. 在项目中连接MySQL<a href="#6-在项目中连接mysql" class="hash-link" aria-label="6. 在项目中连接MySQL的直接链接" title="6. 在项目中连接MySQL的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1. 安装操作 MySQL 数据库的第三方模块（mysql）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    npm i mysql</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2. 通过 mysql 模块连接到 MySQL 数据库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const mysql = require(&#x27;mysql&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const db = mysql.createPool({</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        host: &#x27;127.0.0.1&#x27;,  //数据库 IP 地址</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        user: &#x27;root&#x27;,       //登录数据库的用户名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        password: &#x27;admin&#x27;,  //密码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        database: &#x27;test&#x27;,   //要操作的数据库名称</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3. 通过 mysql 模块执行 SQL 语句</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    db.query(&#x27;&#x27;,()=&gt;{})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="7-使用mysql模块操作数据库增删改查">7. 使用mysql模块操作数据库（增删改查）<a href="#7-使用mysql模块操作数据库增删改查" class="hash-link" aria-label="7. 使用mysql模块操作数据库（增删改查）的直接链接" title="7. 使用mysql模块操作数据库（增删改查）的直接链接">​</a></h6><p><strong>res.affectedRows === 1的时候表示对数据库的操作成功！！</strong></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1. 查询数据     返回的res是数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">查询 users 表中所有的数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const sqlStr = &#x27;select * from users&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    db.query(sqlStr,(err,res)=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">2. 插入数据     返回的res是对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">向 users 表中新增数据， 其中 username 为 Spider-Man，password 为 pcc321。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//要插入表中的数据对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const user = {username = &#x27;Spider-Man&#x27;,password:&#x27;pcc321&#x27;}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ?:表示占位符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const sqlStr = &#x27;insert into users(userName,password) values(?,?)&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//使用数组形式，依次为 ? 占位符指定具体的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    db.query(&#x27;sqlStr&#x27;,[user.username,user,password],(err,res)=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">向表中新增数据时，如果数据对象的每个属性和数据表的字段一一对应，则可以通过如下方式快速插入数据：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//要插入表中的数据对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const user = {username = &#x27;Spider-Man2&#x27;,password:&#x27;pcc123&#x27;}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ?:表示占位符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const sqlStr = &#x27;insert into users set ?&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//直接将数据对象作为占位符的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    db.query(sqlStr,user,(err,res)=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">3.  更新数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">可以通过如下方式，更新表中的数据：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const user = {id:6,username:&#x27;qq&#x27;,password:&#x27;789&#x27;}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const sqlStr = &#x27;update users set userName=?,password=? where id=?&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    db.query(sqlStr,[user.username,user.password,user.id],(err,res)=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">更新表数据时，如果数据对象的每个属性和数据表的字段一一对应，则可以通过如下方式快速更新表数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const user = {id:6,username:&#x27;qq&#x27;,password:&#x27;789&#x27;}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const sqlStr = &#x27;update users set ? where id=?&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    db.query(sqlStr,[user,user.id],(err,res)=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">4. 删除数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">在删除数据时，推荐根据 id 这样的唯一标识，来删除对应的数据。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const sqlStr = &#x27;delete from users where id=?&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    db.query(sqlStr,6,()=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">****标记删除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    使用 DELETE 语句，会把真正的把数据从表中删除掉。为了保险起见，推荐使用标记删除的形式，来模拟删除的动作。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">所谓的标记删除，就是在表中设置类似于 status 这样的状态字段，来标记当前这条数据是否被删除。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">当用户执行了删除的动作时，我们并没有执行 DELETE 语句把数据删除掉，而是执行了 UPDATE 语句，将这条数据对应</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">的 status 字段标记为删除即可。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const sqlStr = &#x27;update users set status=? where id=?&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">db.query(sqlStr,[1,6],()=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="十四web开发模式">十四、web开发模式<a href="#十四web开发模式" class="hash-link" aria-label="十四、web开发模式的直接链接" title="十四、web开发模式的直接链接">​</a></h4><h6 class="anchor anchorWithStickyNavbar_LWe7" id="1-服务端渲染">1. 服务端渲染<a href="#1-服务端渲染" class="hash-link" aria-label="1. 服务端渲染的直接链接" title="1. 服务端渲染的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">服务器发送给客户端的 HTML 页面，是在服务器通过字符串的拼接动态生成的。因此客户端不需要使用 Ajax 额外请求页面的数据。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">示例：     app.get(&#x27;/index.html&#x27;, (req, res) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                const user = { name: &#x27;Bruce&#x27;, age: 29 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                const html = `&lt;h1&gt;username:${user.name}, age:${user.age}&lt;/h1&gt;`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res.send(html)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">优点：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 前端耗时短。浏览器只需直接渲染页面，无需额外请求数据。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 有利于 SEO。服务器响应的是完整的 HTML 页面内容，有利于爬虫爬取信息。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">缺点：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 占用服务器资源。服务器需要完成页面内容的拼接，若请求比较多，会对服务器造成一定访问压力。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 不利于前后端分离，开发效率低。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="2前后端分离的web开发模式">2.前后端分离的web开发模式<a href="#2前后端分离的web开发模式" class="hash-link" aria-label="2.前后端分离的web开发模式的直接链接" title="2.前后端分离的web开发模式的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">前后端分离的开发模式，依赖于 Ajax 技术的广泛应用。后端只负责提供 API 接口，前端使用 Ajax 调用接口。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">优点：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 开发体验好。前端专业页面开发，后端专注接口开发。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 用户体验好。页面局部刷新，无需重新请求页面。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 减轻服务器的渲染压力。页面最终在浏览器里生成。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">缺点：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 不利于 SEO。完整的 HTML 页面在浏览器拼接完成，因此爬虫无法爬取页面的有效信息。Vue、React 等框架的 SSR（server side        render）技术能解决 SEO 问题。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#如何选择</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">企业级网站，主要功能是展示，没有复杂交互，且需要良好的 SEO，可考虑服务端渲染</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">后台管理项目，交互性强，无需考虑 SEO，可使用前后端分离</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">为同时兼顾首页渲染速度和前后端分离开发效率，可采用首屏服务器端渲染+其他页面前后端分离的开发模式</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="十五session--jwt-身份认证">十五、session || JWT 身份认证<a href="#十五session--jwt-身份认证" class="hash-link" aria-label="十五、session || JWT 身份认证的直接链接" title="十五、session || JWT 身份认证的直接链接">​</a></h4><h6 class="anchor anchorWithStickyNavbar_LWe7" id="1-cookie">1. cookie<a href="#1-cookie" class="hash-link" aria-label="1. cookie的直接链接" title="1. cookie的直接链接">​</a></h6><div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">需要安装中间件来使得express可以解析cookie</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token number" style="color:#36acaa">1</span><span class="token plain">.安装cookie-parser</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token function" style="color:#d73a49">yarn</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">add</span><span class="token plain"> cookie-parser</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token number" style="color:#36acaa">2</span><span class="token plain">.引入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                const cookieParser </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> require</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&quot;cookie-parser&quot;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token number" style="color:#36acaa">3</span><span class="token plain">.设置为中间件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                app.use</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">cookieParser</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">))</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">HTTP协议是一个无状态的协议，服务器无法区分请求是否发送自同一个客户端</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            cookie</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                - cookie是HTTP协议中用来解决无状态问题的技术</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                - cookie的本质就是一个头</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    - 服务器以响应头的形式将cookie发送给客户端</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        客户端收到以后会将其存储，并在下次向服务器发送请求时将其传回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        这样服务器就可以根据cookie来识别出客户端了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            cookie是有有效期</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - 默认情况下cookie的有效期就是一次会话（session）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                会话就是一次从打开到关闭浏览器的过程 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - maxAge 用来设置cookie有效时间，单位是毫秒</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            cookie一旦发送给浏览器我们就不能在修改了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         但是我们可以通过发送新的同名cookie来替换旧cookie，从而达到修改的目的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   cookie的不足</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - cookie是由服务器创建，浏览器保存,每次浏览器访问服务器时都需要将cookie发回,这就导致我们不能在cookie存放较多的              数据,并且cookie是直接存储在客户端，容易被篡改盗用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - 注意：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                我们在使用cookie一定不会在cookie存储敏感数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - 所以为了Cookie的不足，我们希望可以这样, 将用户的数据统一存储在服务器中，,每一个用户的数据都有一个对应的id,我们             只需通过cookie将id发送给浏览器,浏览器只需每次访问时将id发回，即可读取到服务器中存储的数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    这个技术我们称之为session（会话）</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="2-session-认证">2. session 认证<a href="#2-session-认证" class="hash-link" aria-label="2. session 认证的直接链接" title="2. session 认证的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">服务端渲染推荐使用 Session 认证机制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#Session 工作原理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">https://brucecai55520.gitee.io/bruceblog/assets/img/Session.c66d5499.png</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">使用：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    1.安装 express-session 中间件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        npm i express-session</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    2.配置中间件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        const session = require(&#x27;express-session&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        app.use(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            session({</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                secret: &#x27;Bruce&#x27;, // 加密，secret 的值为任意字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                resave: false,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                saveUninitalized: true,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    3.向 session 中存数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">中间件配置成功后，可通过 req.session 访问 session 对象，存储用户信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        app.post(&#x27;/api/login&#x27;, (req, res) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            req.session.user = req.body</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            req.session.isLogin = true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res.send({ status: 0, msg: &#x27;login done&#x27; })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    4.从 session 取数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    app.get(&#x27;/api/username&#x27;, (req, res) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!req.session.isLogin) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             return res.send({ status: 1, msg: &#x27;fail&#x27; })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        res.send({ status: 0, msg: &#x27;success&#x27;, username: req.session.user.username })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    5.清空 session</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    app.post(&#x27;/api/logout&#x27;, (req, res) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         // 清空当前客户端的session信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         req.session.destroy()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         res.send({ status: 0, msg: &#x27;logout done&#x27; })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">session是服务器中的一个对象，这个对象用来存储用户的信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        每一个session都会有一个唯一的id，session创建后，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            id会以cookie的形式发送给浏览器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        浏览器收到以后，每次访问都会将id发回，服务器中就可以根据id找到对应的session</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    id（cookie） ----</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> session对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    session什么时候会失效？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        第一种 浏览器的cookie没了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        第二种 服务器中的session对象没了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    express-session默认是将session存储到内存中的，所以服务器一旦重启session会自动重置，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        所以我们使用session通常会对session进行一个持久化的操作（写到文件或数据库）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    如果将session存储到本文件中：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - 需要引入一个中间件session-file-store</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - 使用步骤：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ① 安装</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token function" style="color:#d73a49">yarn</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">add</span><span class="token plain"> session-file-store</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ② 引入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                const FileStore </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> require</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&quot;session-file-store&quot;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">session</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ③ 设置为中间件       </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            app.use</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                session</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    store: new FileStore</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // path用来指定session本地文件的路径</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    path: path.resolve</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">__dirname, </span><span class="token string" style="color:#e3116c">&quot;./sessions&quot;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain">,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 加密</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    secret: </span><span class="token string" style="color:#e3116c">&quot;哈哈&quot;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // session的有效时间 秒 默认1个小时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // ttl: </span><span class="token number" style="color:#36acaa">10</span><span class="token plain">,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 默认情况下，fileStore会每间隔一小时，清除一次session对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // reapInterval 用来指定清除session的间隔，单位秒，默认 </span><span class="token number" style="color:#36acaa">1</span><span class="token plain">小时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // reapInterval: </span><span class="token number" style="color:#36acaa">10</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain">,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    secret: </span><span class="token string" style="color:#e3116c">&quot;dazhaxie&quot;</span><span class="token plain">  //加密</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="2-jwt-认证">2. JWT 认证<a href="#2-jwt-认证" class="hash-link" aria-label="2. JWT 认证的直接链接" title="2. JWT 认证的直接链接">​</a></h6><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">前后端分离推荐使用 JWT（JSON Web Token）认证机制，是目前最流行的跨域认证解决方案</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Session 认证的局限性：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域 Session 认证。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 当前端请求后端接口不存在跨域问题的时候，推荐使用 Session 身份认证机制。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">JWT 工作原理图：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">https://brucecai55520.gitee.io/bruceblog/assets/img/JWT.6a82c41d.png</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过还原 Token 字符串的形式来认证用户的身份。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">JWT 组成部分：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - Header、Payload、Signature</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - Payload 是真正的用户信息，加密后的字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - Header 和 Signature 是安全性相关部分，保证 Token 安全性，三者使用 . 分隔</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">JWT 使用方式：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    客户端会把 JWT 存储在 localStorage 或 sessionStorage 中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    此后客户端与服务端通信需要携带 JWT 进行身份认证，将 JWT 存在 HTTP 请求头 Authorization 字段中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">加上 Bearer 前缀</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Authorization: Bearer &lt;token&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Express 使用 JWT</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1. 安装</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">jsonwebtoken 用于生成 JWT 字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">express-jwt 用于将 JWT 字符串解析还原成 JSON 对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm install jsonwebtoken express-jwt</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2. 导入包及定义 secret 密钥</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">为保证 JWT 字符串的安全性，防止其在网络传输过程中被破解，需定义用于加密和解密的 secret 密钥</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">生成 JWT 字符串时，使用密钥加密信息，得到加密好的 JWT 字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">把 JWT 字符串解析还原成 JSON 对象时，使用密钥解密</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const jwt = require(&#x27;jsonwebtoken&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const expressJWT = require(&#x27;express-jwt&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 密钥为任意字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const secretKey = &#x27;Bruce&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3. 生成 JWT 字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">app.post(&#x27;/api/login&#x27;, (req, res) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  res.send({</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    status: 200,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    message: &#x27;登录成功&#x27;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // jwt.sign() 生成 JWT 字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 参数：用户信息对象、加密密钥、配置对象-token有效期</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 尽量不保存敏感信息，因此只有用户名，没有密码               ***发送给客户端时，要加上&#x27;Bearer &#x27;前缀</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    token: jwt.sign({username: userInfo.username}, secretKey, {expiresIn: &#x27;10h&#x27;})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const res = jwt.verify(生成的token, &quot;加密密钥&quot;)    //对生成的token进行解密,res就是解密后的用户的信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4. JWT 字符串还原为 JSON 对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">客户端访问有权限的接口时，需通过请求头的 Authorization 字段，将 Token 字符串发送到服务器进行身份认证</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">服务器可以通过 express-jwt 中间件将客户端发送过来的 Token 解析还原成 JSON 对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// unless({ path: [/^\/api\//] }) 指定哪些接口无需访问权限</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">app.use(expressJWT({ secret: secretKey }).unless({ path: [/^\/api\//] }))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5. 获取用户信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">当 express-jwt 中间件配置成功后，即可在那些有权限的接口中，使用 req.user 对象，来访问从 JWT 字符串中解析出来的用户信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">app.get(&#x27;/admin/getinfo&#x27;, (req, res) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(req.user)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  res.send({</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    status: 200,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    message: &#x27;获取信息成功&#x27;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    data: req.user,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6. 捕获解析 JWT 失败后产生的错误</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">当使用 express-jwt 解析 Token 字符串时，如果客户端发送过来的 Token 字符串过期或不合法，会产生一个解析失败的错误，影响项目的正常运行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">通过 Express 的错误中间件，捕获这个错误并进行相关的处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">app.use((err, req, res, next) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (err.name === &#x27;UnauthorizedError&#x27;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return res.send({ status: 401, message: &#x27;Invalid token&#x27; })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  res.send({ status: 500, message: &#x27;Unknown error&#x27; })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/3-node.js/1-node.js笔记.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/intro"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">Tutorial Intro</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/node.js/ServerNotes"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">ServerNotes</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.baa843e8.js"></script>
<script src="/assets/js/main.de774768.js"></script>
</body>
</html>